#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HIPAA Compliance Score Calculator
================================

This script analyzes test results, security scans, and other metrics to calculate
an overall HIPAA compliance score. It processes various report files generated by
security testing tools and produces a compliance status determination.

The compliance score is based on:
1. Test coverage and passing rate for security-critical components
2. Absence of high-severity vulnerabilities in code and dependencies
3. Implementation of required HIPAA security controls
4. Code quality and architecture compliance

Usage:
    python check_compliance_score.py --reports-dir reports
"""

import os
import sys
import json
import argparse
import datetime
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional, Tuple

# HIPAA compliance threshold (minimum score to be considered compliant)
COMPLIANCE_THRESHOLD = 80.0

# Weights for different scoring components
SCORE_WEIGHTS = {
    "pytest": 0.3,            # Security tests
    "coverage": 0.15,         # Test coverage
    "bandit": 0.2,            # Static code security analysis
    "safety": 0.15,           # Dependency security
    "hipaa_scanner": 0.2      # HIPAA-specific requirements
}


class ComplianceScoreCalculator:
    """Calculate HIPAA compliance score from various security test results."""
    
    def __init__(self, reports_dir: str):
        """Initialize with reports directory path."""
        self.reports_dir = reports_dir
        self.tool_scores = {}
        self.overall_score = 0.0
        self.critical_issues = []
        self.compliance_status = "NON-COMPLIANT"
        
    def calculate_score(self) -> float:
        """Calculate overall compliance score."""
        self._calculate_pytest_score()
        self._calculate_coverage_score()
        self._calculate_bandit_score()
        self._calculate_safety_score()
        self._calculate_hipaa_scanner_score()
        
        # Calculate weighted average
        weighted_sum = 0.0
        total_weight = 0.0
        
        for tool, weight in SCORE_WEIGHTS.items():
            if tool in self.tool_scores:
                weighted_sum += self.tool_scores[tool] * weight
                total_weight += weight
        
        # If we have no scores, default to 0
        if total_weight == 0:
            self.overall_score = 0.0
        else:
            self.overall_score = weighted_sum / total_weight
        
        # Determine compliance status
        self.compliance_status = "COMPLIANT" if self._is_compliant() else "NON-COMPLIANT"
        
        return self.overall_score
    
    def _calculate_pytest_score(self) -> None:
        """Calculate score from pytest results."""
        try:
            total_tests = 0
            passed_tests = 0
            
            # Read PHI middleware tests
            phi_tests_path = os.path.join(self.reports_dir, "phi_middleware_tests.xml")
            if os.path.exists(phi_tests_path):
                tree = ET.parse(phi_tests_path)
                root = tree.getroot()
                
                tests = int(root.attrib.get("tests", "0"))
                failures = int(root.attrib.get("failures", "0"))
                errors = int(root.attrib.get("errors", "0"))
                skipped = int(root.attrib.get("skipped", "0"))
                
                total_tests += tests
                passed_tests += (tests - failures - errors - skipped)
            
            # Read authentication middleware tests
            auth_tests_path = os.path.join(self.reports_dir, "auth_middleware_tests.xml")
            if os.path.exists(auth_tests_path):
                tree = ET.parse(auth_tests_path)
                root = tree.getroot()
                
                tests = int(root.attrib.get("tests", "0"))
                failures = int(root.attrib.get("failures", "0"))
                errors = int(root.attrib.get("errors", "0"))
                skipped = int(root.attrib.get("skipped", "0"))
                
                total_tests += tests
                passed_tests += (tests - failures - errors - skipped)
            
            # Calculate score based on pass rate
            if total_tests > 0:
                pass_rate = (passed_tests / total_tests) * 100.0
                
                # A higher standard for security tests - we expect near perfect results
                if pass_rate >= 95.0:
                    self.tool_scores["pytest"] = 100.0
                elif pass_rate >= 90.0:
                    self.tool_scores["pytest"] = 90.0
                elif pass_rate >= 80.0:
                    self.tool_scores["pytest"] = 80.0
                elif pass_rate >= 70.0:
                    self.tool_scores["pytest"] = 60.0
                else:
                    self.tool_scores["pytest"] = 40.0
                    self.critical_issues.append(
                        f"Security test pass rate is too low: {pass_rate:.1f}%"
                    )
            else:
                # No tests found
                self.tool_scores["pytest"] = 0.0
                self.critical_issues.append("No security tests found")
        
        except Exception as e:
            print(f"Error calculating pytest score: {str(e)}")
            self.tool_scores["pytest"] = 0.0
    
    def _calculate_coverage_score(self) -> None:
        """Calculate score from test coverage."""
        try:
            coverage_path = os.path.join(self.reports_dir, "coverage.xml")
            if os.path.exists(coverage_path):
                tree = ET.parse(coverage_path)
                root = tree.getroot()
                
                # Find the overall coverage
                coverage = root.attrib.get("line-rate", "0.0")
                try:
                    coverage_pct = float(coverage) * 100.0
                    
                    # Score based on coverage
                    if coverage_pct >= 90.0:
                        self.tool_scores["coverage"] = 100.0
                    elif coverage_pct >= 80.0:
                        self.tool_scores["coverage"] = 90.0
                    elif coverage_pct >= 70.0:
                        self.tool_scores["coverage"] = 80.0
                    elif coverage_pct >= 60.0:
                        self.tool_scores["coverage"] = 70.0
                    elif coverage_pct >= 50.0:
                        self.tool_scores["coverage"] = 60.0
                    else:
                        self.tool_scores["coverage"] = 50.0
                        if coverage_pct < 30.0:
                            self.critical_issues.append(
                                f"Test coverage is critically low: {coverage_pct:.1f}%"
                            )
                
                except ValueError:
                    self.tool_scores["coverage"] = 0.0
            else:
                self.tool_scores["coverage"] = 0.0
                self.critical_issues.append("No test coverage data found")
        
        except Exception as e:
            print(f"Error calculating coverage score: {str(e)}")
            self.tool_scores["coverage"] = 0.0
    
    def _calculate_bandit_score(self) -> None:
        """Calculate score from Bandit security scan."""
        try:
            bandit_path = os.path.join(self.reports_dir, "bandit_results.json")
            if os.path.exists(bandit_path):
                with open(bandit_path, 'r') as f:
                    bandit_data = json.load(f)
                
                # Count issues by severity
                high_count = 0
                medium_count = 0
                low_count = 0
                
                results = bandit_data.get("results", [])
                for result in results:
                    severity = result.get("issue_severity", "").lower()
                    if severity == "high":
                        high_count += 1
                    elif severity == "medium":
                        medium_count += 1
                    elif severity == "low":
                        low_count += 1
                
                # Calculate score based on issues
                # High severity issues heavily penalize the score
                if high_count == 0 and medium_count == 0:
                    self.tool_scores["bandit"] = 100.0
                elif high_count == 0 and medium_count <= 2:
                    self.tool_scores["bandit"] = 90.0
                elif high_count == 0 and medium_count <= 5:
                    self.tool_scores["bandit"] = 80.0
                elif high_count <= 1 and medium_count <= 3:
                    self.tool_scores["bandit"] = 70.0
                elif high_count <= 2 and medium_count <= 5:
                    self.tool_scores["bandit"] = 60.0
                else:
                    self.tool_scores["bandit"] = 40.0
                    if high_count > 0:
                        self.critical_issues.append(
                            f"Found {high_count} high severity security issues"
                        )
            else:
                self.tool_scores["bandit"] = 50.0  # Assume average if no data
        
        except Exception as e:
            print(f"Error calculating bandit score: {str(e)}")
            self.tool_scores["bandit"] = 50.0
    
    def _calculate_safety_score(self) -> None:
        """Calculate score from Safety dependency check."""
        try:
            safety_path = os.path.join(self.reports_dir, "vulnerabilities.json")
            if os.path.exists(safety_path):
                try:
                    with open(safety_path, 'r') as f:
                        vulnerabilities = json.load(f)
                    
                    # Count issues by severity
                    critical_count = 0
                    high_count = 0
                    medium_count = 0
                    
                    for vuln in vulnerabilities:
                        severity = vuln.get("severity", "").lower()
                        if severity == "critical":
                            critical_count += 1
                        elif severity == "high":
                            high_count += 1
                        elif severity == "medium":
                            medium_count += 1
                    
                    # Calculate score based on issues
                    # Critical vulnerabilities are a big problem for HIPAA
                    if critical_count == 0 and high_count == 0:
                        self.tool_scores["safety"] = 100.0
                    elif critical_count == 0 and high_count <= 1:
                        self.tool_scores["safety"] = 85.0
                    elif critical_count == 0 and high_count <= 3:
                        self.tool_scores["safety"] = 70.0
                    elif critical_count <= 1:
                        self.tool_scores["safety"] = 50.0
                        self.critical_issues.append(
                            f"Found {critical_count} critical and {high_count} high severity dependencies"
                        )
                    else:
                        self.tool_scores["safety"] = 0.0
                        self.critical_issues.append(
                            f"Found {critical_count} critical severity dependencies - HIPAA violation"
                        )
                except (json.JSONDecodeError, ValueError):
                    # Empty or invalid file likely means no vulnerabilities
                    self.tool_scores["safety"] = 100.0
            else:
                self.tool_scores["safety"] = 70.0  # Assume decent if no data
        
        except Exception as e:
            print(f"Error calculating safety score: {str(e)}")
            self.tool_scores["safety"] = 70.0
    
    def _calculate_hipaa_scanner_score(self) -> None:
        """Calculate score from HIPAA-specific scan results."""
        # In a real implementation, this would parse results from a HIPAA-specific scanner
        # For this example, we'll use a placeholder score or try to read from a file
        
        try:
            scanner_path = os.path.join(self.reports_dir, "hipaa_scan_results.json")
            if os.path.exists(scanner_path):
                with open(scanner_path, 'r') as f:
                    hipaa_data = json.load(f)
                
                self.tool_scores["hipaa_scanner"] = hipaa_data.get("compliance_score", 75.0)
            else:
                # If no specific HIPAA scan results, estimate based on other scores
                other_scores = [
                    score for tool, score in self.tool_scores.items() 
                    if tool in ["pytest", "bandit", "safety"]
                ]
                
                if other_scores:
                    # HIPAA score is slightly lower than the average of other security scores
                    # This reflects the high standard required for HIPAA compliance
                    avg_score = sum(other_scores) / len(other_scores)
                    self.tool_scores["hipaa_scanner"] = max(0, avg_score - 5)
                else:
                    # Default if we have no other data
                    self.tool_scores["hipaa_scanner"] = 75.0
        
        except Exception as e:
            print(f"Error calculating HIPAA scanner score: {str(e)}")
            self.tool_scores["hipaa_scanner"] = 75.0
    
    def _is_compliant(self) -> bool:
        """
        Determine if the system is HIPAA compliant based on scores and critical issues.
        
        HIPAA compliance requires:
        1. Overall score above the threshold
        2. No critical security issues
        3. No individual component score below 60%
        """
        # Check overall score
        if self.overall_score < COMPLIANCE_THRESHOLD:
            return False
        
        # Check for critical issues
        if self.critical_issues:
            return False
        
        # Ensure no component is severely lacking
        for tool, score in self.tool_scores.items():
            if score < 60.0:
                return False
        
        return True
    
    def write_results(self) -> None:
        """Write compliance results to files."""
        # Write compliance status
        status_path = os.path.join(self.reports_dir, "compliance_status.txt")
        with open(status_path, 'w') as f:
            f.write(self.compliance_status)
        
        # Write detailed score data
        score_path = os.path.join(self.reports_dir, "compliance_score.json")
        score_data = {
            "timestamp": datetime.datetime.now().isoformat(),
            "overall_score": self.overall_score,
            "status": self.compliance_status,
            "tool_scores": self.tool_scores,
            "critical_issues": self.critical_issues
        }
        
        with open(score_path, 'w') as f:
            json.dump(score_data, f, indent=2)
    
    def print_summary(self) -> None:
        """Print a summary of compliance results."""
        print("\n=================================================")
        print("HIPAA COMPLIANCE SCORE SUMMARY")
        print("=================================================")
        
        print(f"\nOverall Compliance Score: {self.overall_score:.1f}%")
        print(f"Compliance Status: {self.compliance_status}")
        
        print("\nComponent Scores:")
        for tool, score in self.tool_scores.items():
            print(f"  {tool}: {score:.1f}%")
        
        if self.critical_issues:
            print("\nCritical Issues:")
            for issue in self.critical_issues:
                print(f"  - {issue}")
        
        print("\n=================================================")
        
        if self.compliance_status == "COMPLIANT":
            print("This platform meets HIPAA security requirements.")
        else:
            print("This platform requires remediation to meet HIPAA requirements.")
        
        print("=================================================\n")


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="HIPAA Compliance Score Calculator")
    parser.add_argument("--reports-dir", default="reports", help="Directory containing security reports")
    
    return parser.parse_args()


def main():
    """Main entry point for the script."""
    args = parse_args()
    
    calculator = ComplianceScoreCalculator(args.reports_dir)
    calculator.calculate_score()
    calculator.write_results()
    calculator.print_summary()
    
    return 0


if __name__ == "__main__":
    sys.exit(main())